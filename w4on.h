#pragma once

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Message IDs:
// "EX" means there is additional data after the message ID

// Generated by protospan.js
#define W4ON_MSG_ID_LONG_WAIT_EX 0x00 // ExLength + W4ON_MSG_COUNT_SHORT_WAIT
#define W4ON_MSG_SPAN_SHORT_WAIT 0x01
#define W4ON_MSG_COUNT_SHORT_WAIT 120
#define W4ON_MSG_SPAN_NOTE_EX 0x79 // ExLength
#define W4ON_MSG_COUNT_NOTE 88
#define W4ON_MSG_SPAN_SEGMENTS 0xd1
#define W4ON_MSG_COUNT_SEGMENTS 16
#define W4ON_MSG_SPAN_ARP_EX 0xe1 // ExLength + 2, [notes...]
#define W4ON_MSG_COUNT_ARP 16
#define W4ON_MSG_ID_SET_VOLUME_EX 0xf1 // [8:volume]
#define W4ON_MSG_ID_SET_A_EX 0xf2 // [8:A]
#define W4ON_MSG_ID_SET_D_EX 0xf3 // [8:D]
#define W4ON_MSG_ID_SET_S_EX 0xf4 // [8:S]
#define W4ON_MSG_ID_SET_R_EX 0xf5 // [8:A]
#define W4ON_MSG_SPAN_SET_PAN 0xf6
#define W4ON_MSG_COUNT_SET_PAN 3
#define W4ON_MSG_ID_SET_ARP_SPEED_EX 0xf9 // [8:ArpSpeed]
#define W4ON_MSG_RESERVED 0xfa
// Unused values: 5

typedef struct {
	uint8_t channel; // 0-3
	uint8_t volume; // 0-100
	uint8_t pulseMode; // 0-3
	uint8_t a, d, r; // 0-255
	uint8_t s; // 0-255 (ratio)
	uint8_t pan; // 0-2 (center, left, right)
	uint8_t arpSpeed; // 0-255

	uint8_t segmentsLeft; // Amount of segments upcoming
	uint8_t eventValue; // 0-87 = midi note number (0 = A0) for note, amount of arp notes if arp
	uint16_t dataI, dataEndI; // Position in data
	uint16_t arpNoteDataI; // 0 = no arp active, otherwise index to note list
	uint16_t eventTick; // How many ticks has passed since the last event
	uint16_t eventTicksLeft; // How many ticks are left of the current event
} w4on_track_t;

typedef struct {
	const uint8_t *data;
	w4on_track_t tracks[8]; // TODO: either make this configurable, or make the converter crunch everything into 8 tracks in an optimal way
} w4on_seq_t;

// TODO: enable looping
void w4on_seq_init(w4on_seq_t *seq, const uint8_t *data);
bool w4on_seq_tick(w4on_seq_t *seq); // TODO: master volume
